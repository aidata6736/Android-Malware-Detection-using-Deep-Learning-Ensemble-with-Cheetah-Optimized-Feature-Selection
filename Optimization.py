import numpy as np
# Cheetah Optimization Algorithm + velocity strategy particle swarm optimization algorithm


def pro_optimization(Objective_function, lb, ub, pop_size, prob_size, epochs):
    population = np.random.uniform(lb, ub, size=(pop_size, prob_size))
    best_solution = None
    best_fitness = float('inf')
    lb = np.array(lb)
    ub = np.array(ub)
    for i in range(epochs):
        for j in range(pop_size):
            population[j, population[j] < lb] = lb[population[j] < lb]
            population[j, population[j] > ub] = ub[population[j] > ub]
            fitness = Objective_function(population[j])

            if fitness < best_fitness:
                best_solution = population[j]
                best_fitness = fitness

            # search strategy
            # Exploration
            Zmax = max(population[j])
            Zmin = min(population[j])
            # search radius  - RD
            RD = 0.1 * np.sqrt((Zmax - Zmin) / (2*prob_size))  # Hyb - updation condion is based on RD value
            cond = Objective_function(population[j])*(best_solution - (population[j]*RD*np.random.uniform(-1, 1)))
            if cond.any() < 0 :
                beta = 0.001 * (i / epochs) * (ub[j] - lb[j])
                population[j] = population[j] + np.random.uniform(0, 1) * beta
            # Exploitation - Hyb (velocity is updated using variable velocity strategy particle swarm optimization algorithm (VVS-PSO)
            # attack strategy
            elif cond.any() > 0:
                v_min = 0.4
                v_max = 0.9
                v = v_min + (i / epochs) * (v_max - v_min)  # v balance between  the exploration and exploitation part
                rands = np.random.uniform(0, 1, 4)
                b1, b2, q1, q2 = rands[0], rands[1], rands[2], rands[3]
                population[j] = v * population[j]  + b1*q1*(best_solution - population[j]) + b2*q2*(best_solution-population[j]) + cond

            # sitting and waiting strategy
            else:
                population[j] = population[j]


    return best_solution, best_fitness



